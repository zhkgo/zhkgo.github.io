---
title: 子矩阵
date: 2018-03-08 11:32:52
tags: [算法,动态规划]
img: images/20200910170835.jpeg
---

题目描述
链接如下
<https://www.luogu.org/problemnew/show/P2258>

```
给出如下定义：

子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

例如，下面左图中选取第2、4行和第2、4、5列交叉位置的元素得到一个2*3的子矩阵如右图所示。

9 3 3 3 9

9 4 8 7 4

1 7 4 6 6

6 8 5 6 9

7 4 5 6 1

的其中一个2*3的子矩阵是

4 7 4

8 6 9

相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个n行m列的正整数矩阵，请你从这个矩阵中选出一个r行c列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

(本题目为2014NOIP普及T4)

输入输出格式

输入格式：

第一行包含用空格隔开的四个整数n，m，r，c，意义如问题描述中所述，每两个整数之间用一个空格隔开。

接下来的n行，每行包含m个用空格隔开的整数，用来表示问题描述中那个n行m列的矩阵。

输出格式：

输出共1行，包含1个整数，表示满足题目描述的子矩阵的最小分值。

【数据说明】

对于50%的数据，1 ≤ n ≤ 12，1 ≤ m ≤ 12，矩阵中的每个元素1 ≤ a[i][j] ≤ 20；

对于100%的数据，1 ≤ n ≤ 16，1 ≤ m ≤ 16，矩阵中的每个元素1 ≤ a[i][j] ≤ 1,000，

1 ≤ r ≤ n，1 ≤ c ≤ m。
```

对于以上的数据范围，我一开始想到的是直接搜索，然后我就估算了一下搜索的代价，最差的情况是，有16行16列，选8行8列，直接枚举的话，有

![ ][1]
的运算次数，结果是超过100亿的运算次数显然不能再规定时间内完成。

看到这类矩阵 ，我也能想到是dp，但是对于这种选择分开的dp感觉无从下手。

后来想到，将dp与搜索结合起来使用，先搜索确定是那几行，然后题目就变成了

从m列里选择c列 ，找出最小的分值，这样就可以进行dp了,dp的复杂度是16^3。

最差的情况也只是5000多万次运算。

首先确定状态，状态为dp[i][j]

i表示选择的最后一个列，j表示已经选择的列数。

显然j<=i

状态转移方程也显而易见

dp[i][j]=min(dp[k][j-1]+col[i]+cha[k][i]),k<=i;

其中col[i]表示i列内部之间的分值，cha[k][i]表示第k列与第i列相邻时，他们列之间相差的分值。这两个数组可以在确定行之后预处理出来，预处理的时间是O(n\^2)相对于dp的O(n^3）显然可以忽略不计。

下面附上代码。

```cpp
#include<stdio.h>
#include<string.h>
int n,m,r,c;
int mp[20][20];
int chose[20];
int dp[20][20];
int res=0x3f3f3f3f;
inline int myabs(int a){
    return a>=0?a:-a;
}
inline int mymax(int a,int b){
    return a>b?a:b;
}
inline int mymin(int a,int b){
    return a<b?a:b;
}
void solve(){
    memset(dp,0x3f,sizeof(dp));
    int f[20][20];
    for(int i=1;i<m;i++){
        for(int j=i+1;j<=m;j++){
            f[i][j]=0;
            for(int k=0;k<r;k++){
                f[i][j]+=myabs(mp[chose[k]][i]-mp[chose[k]][j]);
            }
        }
    }
    int col[20];
    for(int i=1;i<=m;i++){
        col[i]=0;
        for(int j=1;j<r;j++){
            col[i]+=myabs(mp[chose[j]][i]-mp[chose[j-1]][i]);
        }
    }
    for(int i=1;i<=m;i++){
        dp[i][1]=col[i];
    }
    for(int i=2;i<=m;i++){
        int minc=i<c?i:c;
        for(int j=2;j<=minc;j++){
            for(int k=j-1;k<i;k++){
                dp[i][j]=mymin(dp[i][j],dp[k][j-1]+col[i]+f[k][i]);
            }
        }
    }
    for(int i=c;i<=m;i++){
        res=mymin(dp[i][c],res);
    }
}
void dfs(int x,int now){
    if(x==r){
        solve();
        return;
    }
    if(r-x>n-now+1)return;
    for(int i=now;i<=n;i++){
        chose[x]=i;
        dfs(x+1,i+1);
    }
} 
int main(){
    scanf("%d%d",&n,&m);
    scanf("%d%d",&r,&c);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",mp[i]+j);
        }
    }
    dfs(0,1);
    printf("%d\n",res);
    return 0;
} 
```

  [1]: http://latex.codecogs.com/gif.latex?(C_{16}^{8}%20)^{2}*{n}^2
